<video></video>
<canvas></canvas>
<button id="stop">Stop / Restart</button>
<button id="ghost">Ghost mode</button>
<button id="save">Save</button>
<button id="wipe">Wipe</button>
<script src="https://unpkg.com/face-api.js@0.16.2/dist/face-api.min.js"></script>
<script>
  stopped = false;
  const videoInput = document.querySelector("video");
  const stopButton = document.getElementById('stop');
  var canvas = document.querySelector("canvas");
  var ctx = canvas.getContext("2d");

  stopButton.onclick = function () {
      stopped = !stopped;
  }

  const ghostButton = document.getElementById('ghost');
  ghostButton.onclick = () => {
    videoInput.classList.toggle('hidden')
  }
  const saveButton = document.getElementById('save');
  saveButton.onclick = function() {
    canvas.toBlob(blob => {
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'facepaint-' + Date.now();
        a.click();
    })
  }

  const wipeButton = document.getElementById('wipe');
  wipeButton.onclick = () => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  }
    
  async function startApp() {
    await faceapi.loadSsdMobilenetv1Model("/models");
    // debugger
    await faceapi.loadFaceLandmarkTinyModel("/models");
    await faceapi.loadFaceLandmarkModel("/models");
    // debugger
    // Prefer camera resolution nearest to 1280x720.
    var constraints = { video: { width: 1280, height: 720 } };

    async function drawOnFaces() {
        if (stopped === false) {
            const faces = await faceapi.detectAllFaces(videoInput);
            const facesWithLandmarks = await faceapi.detectAllFaces(videoInput).withFaceLandmarks();
            for (const fancyFace of facesWithLandmarks) {
            const mouthPoints = fancyFace.landmarks.getMouth();
            const nosePoints = fancyFace.landmarks.getNose();
            const leftEyePoints = fancyFace.landmarks.getLeftEye();
            const rightEyePoints = fancyFace.landmarks.getRightEye();
                for(nosePoint of nosePoints) {
                    ctx.fillStyle = 'green';
                    ctx.fillRect(nosePoint.x, nosePoint.y, 5, 5);
                }

                for(mouthPoint of mouthPoints) {
                    ctx.fillStyle = 'red';
                    ctx.fillRect(mouthPoint.x, mouthPoint.y, 5, 5);
                }

                for(eyePoint of [...leftEyePoints, ...rightEyePoints]) {
                    ctx.fillStyle = 'steelblue';
                    ctx.fillRect(eyePoint.x, eyePoint.y, 5, 5);
                }
            }
        }

        window.requestAnimationFrame(drawOnFaces);
    }

    navigator.mediaDevices
      .getUserMedia(constraints)
      .then(function(mediaStream) {
        var video = document.querySelector("video");
        video.srcObject = mediaStream;
        video.onloadedmetadata = function(e) {
          console.log(video);
          console.log("in onloadedmetadata");
          video.play();
          const videoDimensions = faceapi.getMediaDimensions(document.querySelector('video'));
          canvas.width = videoDimensions.width;
          canvas.height = videoDimensions.height;
          // drawOnFaces()
        };
        console.log("end of mediastream thingy");
        video.onplay = function() {
          drawOnFaces();
        };
      })
      .catch(function(err) {
        console.log(err.name + ": " + err.message);
      }); // always check for errors at the end.
  }
  startApp();

</script>
<style>
  video,
  canvas {
    position: absolute;
    left: 0;
    top: 0;
  }
  button {
    position: relative;
  }
  .hidden {
      display: none;
  }
</style>